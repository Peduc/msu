%{
Используя схемы ERK1 и ERK2, смоделируйте движение Земли вокруг Солнца в течение года. 
Для начала можете считать Солнце неподвижным 
(т.е. решать задачу о движении материальной точки в центральном поле силы). 

Данные (конечно, в системе СИ), которые я нашёл в Интернете, следующие: 
(небесные тела даны с запасом для выполнения последующих заданий) 

% Заданы: Солнце, Земля, Луна (Земля в афелии, для Луны взяты средние данные), комета Галлея 
mass = [1.9891*10^30; 5.9736*10^24; 7.3477*10^22; 2.2*10^14]; 
coordinates = [0 0; 1.52098232*10^11 0; 1.52098232*10^11+3.84467*10^8 0; 5.24824*10^12 0]; 
velocities = [0 -0.089021687078894; 0 29270; 0 29270+1023; 0 -900]; 

% Гравитационная постоянная 
g = 6.67300*10^(-11); 

Если для Луны найдёте более точные данные 
(например расстояние до земли и соответствующую скорость в апогее или перигее), 
то буду благодарен, если вы их здесь опубликуете. 

Хочу лишний раз отметить, что, понятное дело, 
без вычисления апостериорных оценок точностей полученного решения ваша программа
по сути будет являться генератором случайных чисел. 
Убедиться в том, что всё вами реализовано правильно вы сможете наглядно,
используя априорную информацию о том, что через 1 год Земля должна вернуться 
в ту же самую точку пространства. Но также убедитесь и в том, что результат сильно зависит 
от выбранного шага по времени - в случае неудачного шага Земля может, например, 
набрать 3-ю космическую скорость и покинуть солнечную систему. 
%}

mass = [1.9891*10^30; 5.9736*10^24]; %Солнце/Земля
coordinates = [0 0; 1.52098232*10^11 0]; %x,y Солнца ; x,y Земли 
velocities = [0 -0.089021687078894; 0 29270]; %Vx,Vy Солнца; vx, Vy Земли
G = 6.67300*10^(-11); % Гравитационная постоянная 
N=365*24*60*60;

%ERK-mode: 1 - ERK1, 2 - ERK2, 3 - ERK3
mode=2; 
tau=0.524*60*60;

Un=[coordinates(2,1); coordinates(2,2); velocities(2,1); velocities(2,2)];
fn=[velocities(2,1); velocities(2,2);-G*mass(1)*coordinates(2,1)/( (coordinates(2,1))^2+( coordinates(2,2) )^2 )^(3/2); -G*mass(1)*coordinates(2,2)/( (coordinates(2,1))^2+( coordinates(2,2) )^2 )^(3/2)];
X1=[];
Y1=[];
Uw2=[];
if mode == 1
     for n=1:N
         X1(n)=Un(1);
         Y1(n)=Un(2);
         Un=Un+tau*fn;
         fn=[Un(3); Un(4); -G*mass(1)*Un(1)/( Un(1)^2 + Un(2)^2 )^(3/2); -G*mass(1)*Un(2)/( Un(1)^2 + Un(2)^2 )^(3/2) ];
     end
     
     figure(1);
     plot(X1, Y1);
end

if mode == 2
    for n=1:N
      X1(n)=Un(1);
      Y1(n)=Un(2);
      Uw2=Un+2/3*fn*tau;
      w2n=[Uw2(3); Uw2(4); -G*mass(1)*Uw2(1)/( Uw2(1)^2 + Uw2(2)^2 )^(3/2); -G*mass(1)*Uw2(2)/( Uw2(1)^2 + Uw2(2)^2 )^(3/2)];
      Un=Un+tau*( fn/4 +  3/4*w2n);
      fn=[Un(3); Un(4); -G*mass(1)*Un(1)/( Un(1)^2 + Un(2)^2 )^(3/2); -G*mass(1)*Un(2)/( Un(1)^2 + Un(2)^2 )^(3/2) ];
    end
     figure(2);
     X11=X1';
     X22=Y1';
     plot(X1', Y1');
end

if mode == 3
    for n=1:N
        X1(n)=Un(1);
        Y1(n)=Un(2);
        Uw2=Un+1/2*tau*fn;
        w2n=[Uw2(3); Uw2(4); -G*mass(1)*Uw2(1)/( Uw2(1)^2 + Uw2(2)^2 )^(3/2); -G*mass(1)*Uw2(2)/( Uw2(1)^2 + Uw2(2)^2 )^(3/2)];
        Uw3=Un+3/4*tau*w2n;
        w3n=[Uw3(3); Uw3(4); -G*mass(1)*Uw3(1)/( Uw3(1)^2 + Uw3(2)^2 )^(3/2); -G*mass(1)*Uw2(2)/( Uw3(1)^2 + Uw3(2)^2 )^(3/2)];
        Un=Un+tau*(2/9*fn+1/3*w2n+4/9*w3n);
        fn=[Un(3); Un(4); -G*mass(1)*Un(1)/( Un(1)^2 + Un(2)^2 )^(3/2); -G*mass(1)*Un(2)/( Un(1)^2 + Un(2)^2 )^(3/2)];
        
    end
    figure(3);
    plot(X1',Y1');
end















